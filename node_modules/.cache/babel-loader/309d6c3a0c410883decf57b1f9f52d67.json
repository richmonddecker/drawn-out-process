{"ast":null,"code":"var sketch = function sketch(p) {\n  var aspect = 2 / p.sqrt(3);\n  var radius = 0;\n  var lastMillis = 0;\n  var settings = {\n    numSides: 3\n  };\n\n  function clearPolygon(n) {\n    p.background(0.3);\n    drawPolygon(n);\n  }\n\n  p.setup = function () {\n    //if (window.innerHeight < 4)\n    radius = p.min(window.innerWidth, window.innerHeight) / 2;\n    p.createCanvas(2 * radius, 2 * radius);\n    p.colorMode(p.HSB, 1);\n    clearPolygon(settings.numSides);\n  };\n\n  p.draw = function () {\n    var ellapsed = getEllapsedTime();\n    var coords = getCoords(); //let settings = getSettings();\n\n    if (shouldDraw()) {\n      makeLines(coords, settings, ellapsed);\n    }\n\n    drawPolygon(settings.numSides);\n  };\n\n  p.interpretProps = function (_ref) {\n    var controls = _ref.controls;\n    console.log(\"SETTINGS NOW: \");\n  };\n\n  function sidewaysFactor(n) {\n    // Get the horizontal factor for a polygon of n sides.\n    var cosineSum = 0;\n\n    for (var i = 0; i < p.floor((n + 1) / 4); i++) {\n      cosineSum += p.cos(p.TWO_PI * i / n);\n    }\n\n    return cosineSum * 2 * p.sin(p.PI / n);\n  }\n\n  function drawPolygon(n) {\n    var factor = sidewaysFactor(n);\n    var size = radius * factor;\n    console.log(\"SIZE IS: \", size, factor);\n    p.push();\n    p.translate(radius, size - 20);\n    p.rotate(-p.PI / 2);\n    p.noStroke();\n    p.fill(1);\n    p.beginShape();\n    var angle;\n\n    if (n % 2) {\n      for (var i = 0; i < n; i++) {\n        angle = p.TWO_PI * i / n;\n        p.vertex(size * p.cos(angle), size * p.sin(angle));\n      }\n    }\n\n    p.endShape(p.CLOSE);\n    p.pop();\n  }\n\n  function getCoords() {\n    var x = p.mouseX - p.width / 2;\n    var y = p.mouseY - p.height / 2;\n    return {\n      x: x,\n      y: y,\n      r: p.sqrt(p.sq(x) + p.sq(y)),\n      th: p.PI + p.atan2(y, x)\n    };\n  }\n\n  function getColor(coords, settings) {\n    if (coords.r > radius) {\n      return p.color(0, 0, 0, 1);\n    }\n\n    var h = (settings.hueCycles * (coords.th / p.TWO_PI + 1.75) + 1 + settings.hueOffset / 360.0) % 1.0;\n    var s = p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    var b = 0.5 + 0.5 * p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    var a = settings.lineOpacity / 100.0;\n    return p.color(h, s, b, a);\n  }\n\n  function getAngleSpan(coords, settings) {\n    return p.PI * p.pow((radius - coords.r) / radius, settings.spanPower);\n  }\n\n  function getEllapsedTime() {\n    var nextMillis = p.millis();\n    var ellapsed = nextMillis - lastMillis;\n    lastMillis = nextMillis;\n    return ellapsed / 1000.0;\n  }\n\n  function getNumLines(settings, ellapsed) {\n    var factor = ellapsed * settings.lineSpeed;\n    var numLines = p.floor(factor);\n\n    if (p.random(0, 1) < factor % 1) {\n      numLines += 1;\n    }\n\n    return numLines;\n  }\n\n  function drawLine(span) {\n    p.push();\n    p.rotate(p.random(-span / 2, span / 2));\n    p.line(0, -2 * radius, 0, 2 * radius);\n    p.pop();\n  }\n\n  function makeLines(coords, settings, ellapsed) {\n    if (coords.r > radius) {\n      return;\n    }\n\n    var numLines = getNumLines(settings, ellapsed);\n    var span = getAngleSpan(coords, settings);\n    p.push();\n    p.translate(coords.x + p.width / 2, coords.y + p.height / 2);\n    p.rotate(coords.th);\n    p.strokeWeight(settings.lineThickness);\n    p.stroke(getColor(coords, settings));\n\n    for (var i = 0; i < numLines; i++) {\n      drawLine(span);\n    }\n\n    p.pop();\n  }\n\n  function shouldDraw() {\n    return !p.isBlocked && p.mouseIsPressed;\n  }\n};\n\nexport default sketch;","map":{"version":3,"sources":["/Users/richmonddecker/Documents/DrawnOutProcess/drawn-out-process/src/sketches/polystrings.js"],"names":["sketch","p","aspect","sqrt","radius","lastMillis","settings","numSides","clearPolygon","n","background","drawPolygon","setup","min","window","innerWidth","innerHeight","createCanvas","colorMode","HSB","draw","ellapsed","getEllapsedTime","coords","getCoords","shouldDraw","makeLines","interpretProps","controls","console","log","sidewaysFactor","cosineSum","i","floor","cos","TWO_PI","sin","PI","factor","size","push","translate","rotate","noStroke","fill","beginShape","angle","vertex","endShape","CLOSE","pop","x","mouseX","width","y","mouseY","height","r","sq","th","atan2","getColor","color","h","hueCycles","hueOffset","s","pow","colorPower","b","a","lineOpacity","getAngleSpan","spanPower","nextMillis","millis","getNumLines","lineSpeed","numLines","random","drawLine","span","line","strokeWeight","lineThickness","stroke","isBlocked","mouseIsPressed"],"mappings":"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","sourcesContent":["const sketch = (p) => {\n  const aspect = 2 / p.sqrt(3);\n  let radius = 0;\n  let lastMillis = 0;\n  let settings = {\n    numSides: 3\n  }\n\n  function clearPolygon(n) {\n    p.background(0.3);\n    drawPolygon(n);\n  }\n\n  p.setup = function() {\n    //if (window.innerHeight < 4)\n    radius = p.min(window.innerWidth, window.innerHeight) / 2;\n    p.createCanvas(2 * radius, 2 * radius);\n    p.colorMode(p.HSB, 1);\n    clearPolygon(settings.numSides);\n  }\n\n  p.draw = function() {\n    let ellapsed = getEllapsedTime();\n    let coords = getCoords();\n    //let settings = getSettings();\n    if (shouldDraw()) {\n      makeLines(coords, settings, ellapsed);\n    }\n    drawPolygon(settings.numSides);\n  }\n\n  p.interpretProps = function({ controls }) {\n    console.log(\"SETTINGS NOW: \")\n  }\n\n  function sidewaysFactor(n) {\n    // Get the horizontal factor for a polygon of n sides.\n    let cosineSum = 0;\n    for (let i = 0; i < p.floor((n + 1) / 4); i++) {\n      cosineSum += p.cos(p.TWO_PI * i / n);\n    }\n    return cosineSum * 2 * p.sin(p.PI / n);\n  }\n\n  function drawPolygon(n) {\n    const factor = sidewaysFactor(n);\n    const size = radius * factor;\n    console.log(\"SIZE IS: \", size, factor)\n    p.push();\n    p.translate(radius, size-20);\n    p.rotate(-p.PI / 2);\n    p.noStroke();\n    p.fill(1);\n    p.beginShape();\n    let angle;\n    if (n % 2) {\n      for (let i = 0; i < n; i++) {\n        angle = p.TWO_PI * i / n;\n        p.vertex(size * p.cos(angle), size * p.sin(angle));\n      }\n    }\n    p.endShape(p.CLOSE);\n    p.pop();\n  }\n\n  function getCoords() {\n    let x = p.mouseX - p.width/2;\n    let y = p.mouseY - p.height/2;\n    return {\n      x: x,\n      y: y,\n      r: p.sqrt(p.sq(x) + p.sq(y)),\n      th: p.PI + p.atan2(y, x)\n    };\n  }\n\n  function getColor(coords, settings) {\n    if (coords.r > radius) {\n      return p.color(0, 0, 0, 1);\n    }\n    let h = (settings.hueCycles * (coords.th / p.TWO_PI + 1.75) + 1 + settings.hueOffset / 360.0) % 1.0\n    let s = p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    let b = (0.5 + 0.5 * p.pow(coords.r / radius, 1.0 / settings.colorPower));\n    let a = settings.lineOpacity / 100.0;\n    return p.color(h, s, b, a);\n  }\n\n  function getAngleSpan(coords, settings) {\n    return p.PI * p.pow((radius - coords.r) / radius, settings.spanPower);\n  }\n\n  function getEllapsedTime() {\n    let nextMillis = p.millis();\n    let ellapsed = nextMillis - lastMillis;\n    lastMillis = nextMillis;\n    return ellapsed / 1000.0;\n  }\n\n  function getNumLines(settings, ellapsed) {\n    let factor = ellapsed * settings.lineSpeed;\n    let numLines = p.floor(factor);\n    if (p.random(0, 1) < factor % 1) {\n      numLines += 1;\n    }\n    return numLines;\n  }\n\n  function drawLine(span) {\n    p.push();\n    p.rotate(p.random(-span/2, span/2));\n    p.line(0, -2 * radius, 0, 2 * radius);\n    p.pop();\n  }\n\n  function makeLines(coords, settings, ellapsed) {\n    if (coords.r > radius) {\n      return;\n    }\n    let numLines = getNumLines(settings, ellapsed);\n    let span = getAngleSpan(coords, settings);\n    p.push();\n    p.translate(coords.x + p.width/2, coords.y + p.height/2);\n    p.rotate(coords.th);\n    p.strokeWeight(settings.lineThickness);\n    p.stroke(getColor(coords, settings));\n    for (let i = 0; i < numLines; i++) {\n      drawLine(span);\n    }\n    p.pop();\n  }\n\n  function shouldDraw() {\n    return !p.isBlocked && p.mouseIsPressed;\n  }\n};\n\nexport default sketch;\n"]},"metadata":{},"sourceType":"module"}