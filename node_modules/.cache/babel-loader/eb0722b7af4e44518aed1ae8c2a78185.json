{"ast":null,"code":"var sketch = function sketch(p) {\n  var radius = 0;\n  var lastMillis = 0;\n  var settings = {\n    numSides: 3,\n    hueOffset: 0,\n    lineSpeed: 1000,\n    lineThickness: 1,\n    lineOpacity: 50,\n    spanPower: 1,\n    colorPower: 2\n  };\n\n  function clearPolygon(n) {\n    p.background(55);\n    drawPolygon(n);\n  }\n\n  p.setup = function () {\n    var n = 5;\n    radius = p.min(window.innerWidth, window.innerHeight) / 2;\n    p.createCanvas(2 * radius, 2 * radius);\n    p.colorMode(p.HSB, 1);\n    clearPolygon(n);\n  };\n\n  p.draw = function () {\n    var ellapsed = getEllapsedTime();\n    var coords = getCoords(); //let settings = getSettings();\n\n    if (shouldDraw()) {\n      makeLines(coords, settings, ellapsed);\n    }\n\n    drawBorder();\n  };\n\n  p.interpretProps = function (_ref) {\n    var controls = _ref.controls;\n    settings.hueCycles = parseFloat(controls.hueCycles, 10);\n    settings.hueOffset = parseFloat(controls.hueOffset, 10);\n    settings.lineSpeed = parseFloat(controls.lineSpeed, 10);\n    settings.lineThickness = parseFloat(controls.lineThickness, 10);\n    settings.lineOpacity = parseFloat(controls.lineOpacity, 10);\n    settings.spanPower = parseFloat(controls.spanPower, 10);\n    settings.colorPower = parseFloat(controls.colorPower, 10);\n    console.log(\"SETTINGS NOW: \");\n  };\n\n  function drawPolygon(n) {\n    p.push();\n    p.translate(radius, radius);\n    p.rotate(p.PI / 2);\n    p.noStroke();\n    p.fill(255);\n    p.beginShape();\n    var angle;\n\n    if (n % 2) {\n      for (var i = 0; i < n; i++) {\n        angle = p.TWO_PI * i / n;\n        p.vertex(radius * p.cos(angle), radius * p.sin(angle));\n      }\n    }\n\n    p.endShape(p.CLOSE);\n    p.pop();\n  }\n\n  function getCoords() {\n    var x = p.mouseX - p.width / 2;\n    var y = p.mouseY - p.height / 2;\n    return {\n      x: x,\n      y: y,\n      r: p.sqrt(p.sq(x) + p.sq(y)),\n      th: p.PI + p.atan2(y, x)\n    };\n  }\n\n  function getColor(coords, settings) {\n    if (coords.r > radius) {\n      return p.color(0, 0, 0, 1);\n    }\n\n    var h = (settings.hueCycles * (coords.th / p.TWO_PI + 1.75) + 1 + settings.hueOffset / 360.0) % 1.0;\n    var s = p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    var b = 0.5 + 0.5 * p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    var a = settings.lineOpacity / 100.0;\n    return p.color(h, s, b, a);\n  }\n\n  function getAngleSpan(coords, settings) {\n    return p.PI * p.pow((radius - coords.r) / radius, settings.spanPower);\n  }\n\n  function getEllapsedTime() {\n    var nextMillis = p.millis();\n    var ellapsed = nextMillis - lastMillis;\n    lastMillis = nextMillis;\n    return ellapsed / 1000.0;\n  }\n\n  function getNumLines(settings, ellapsed) {\n    var factor = ellapsed * settings.lineSpeed;\n    var numLines = p.floor(factor);\n\n    if (p.random(0, 1) < factor % 1) {\n      numLines += 1;\n    }\n\n    return numLines;\n  }\n\n  function drawLine(span) {\n    p.push();\n    p.rotate(p.random(-span / 2, span / 2));\n    p.line(0, -2 * radius, 0, 2 * radius);\n    p.pop();\n  }\n\n  function makeLines(coords, settings, ellapsed) {\n    if (coords.r > radius) {\n      return;\n    }\n\n    var numLines = getNumLines(settings, ellapsed);\n    var span = getAngleSpan(coords, settings);\n    p.push();\n    p.translate(coords.x + p.width / 2, coords.y + p.height / 2);\n    p.rotate(coords.th);\n    p.strokeWeight(settings.lineThickness);\n    p.stroke(getColor(coords, settings));\n\n    for (var i = 0; i < numLines; i++) {\n      drawLine(span);\n    }\n\n    p.pop();\n  }\n\n  function shouldDraw() {\n    return !p.isBlocked && p.mouseIsPressed;\n  }\n};\n\nexport default sketch;","map":{"version":3,"sources":["/Users/richmonddecker/Documents/DrawnOutProcess/drawn-out-process/src/sketches/polystrings.js"],"names":["sketch","p","radius","lastMillis","settings","numSides","hueOffset","lineSpeed","lineThickness","lineOpacity","spanPower","colorPower","clearPolygon","n","background","drawPolygon","setup","min","window","innerWidth","innerHeight","createCanvas","colorMode","HSB","draw","ellapsed","getEllapsedTime","coords","getCoords","shouldDraw","makeLines","drawBorder","interpretProps","controls","hueCycles","parseFloat","console","log","push","translate","rotate","PI","noStroke","fill","beginShape","angle","i","TWO_PI","vertex","cos","sin","endShape","CLOSE","pop","x","mouseX","width","y","mouseY","height","r","sqrt","sq","th","atan2","getColor","color","h","s","pow","b","a","getAngleSpan","nextMillis","millis","getNumLines","factor","numLines","floor","random","drawLine","span","line","strokeWeight","stroke","isBlocked","mouseIsPressed"],"mappings":"AAAA,IAAMA,MAAM,GAAG,SAATA,MAAS,CAACC,CAAD,EAAO;AACpB,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,UAAU,GAAG,CAAjB;AACA,MAAIC,QAAQ,GAAG;AACbC,IAAAA,QAAQ,EAAE,CADG;AAEbC,IAAAA,SAAS,EAAE,CAFE;AAGbC,IAAAA,SAAS,EAAE,IAHE;AAIbC,IAAAA,aAAa,EAAE,CAJF;AAKbC,IAAAA,WAAW,EAAE,EALA;AAMbC,IAAAA,SAAS,EAAE,CANE;AAObC,IAAAA,UAAU,EAAE;AAPC,GAAf;;AAUA,WAASC,YAAT,CAAsBC,CAAtB,EAAyB;AACvBZ,IAAAA,CAAC,CAACa,UAAF,CAAa,EAAb;AACAC,IAAAA,WAAW,CAACF,CAAD,CAAX;AACD;;AAEDZ,EAAAA,CAAC,CAACe,KAAF,GAAU,YAAW;AACnB,QAAIH,CAAC,GAAG,CAAR;AACAX,IAAAA,MAAM,GAAGD,CAAC,CAACgB,GAAF,CAAMC,MAAM,CAACC,UAAb,EAAyBD,MAAM,CAACE,WAAhC,IAA+C,CAAxD;AACAnB,IAAAA,CAAC,CAACoB,YAAF,CAAe,IAAInB,MAAnB,EAA2B,IAAIA,MAA/B;AACAD,IAAAA,CAAC,CAACqB,SAAF,CAAYrB,CAAC,CAACsB,GAAd,EAAmB,CAAnB;AACAX,IAAAA,YAAY,CAACC,CAAD,CAAZ;AACD,GAND;;AAQAZ,EAAAA,CAAC,CAACuB,IAAF,GAAS,YAAW;AAClB,QAAIC,QAAQ,GAAGC,eAAe,EAA9B;AACA,QAAIC,MAAM,GAAGC,SAAS,EAAtB,CAFkB,CAGlB;;AACA,QAAIC,UAAU,EAAd,EAAkB;AAChBC,MAAAA,SAAS,CAACH,MAAD,EAASvB,QAAT,EAAmBqB,QAAnB,CAAT;AACD;;AACDM,IAAAA,UAAU;AACX,GARD;;AAUA9B,EAAAA,CAAC,CAAC+B,cAAF,GAAmB,gBAAuB;AAAA,QAAZC,QAAY,QAAZA,QAAY;AACxC7B,IAAAA,QAAQ,CAAC8B,SAAT,GAAqBC,UAAU,CAACF,QAAQ,CAACC,SAAV,EAAqB,EAArB,CAA/B;AACA9B,IAAAA,QAAQ,CAACE,SAAT,GAAqB6B,UAAU,CAACF,QAAQ,CAAC3B,SAAV,EAAqB,EAArB,CAA/B;AACAF,IAAAA,QAAQ,CAACG,SAAT,GAAqB4B,UAAU,CAACF,QAAQ,CAAC1B,SAAV,EAAqB,EAArB,CAA/B;AACAH,IAAAA,QAAQ,CAACI,aAAT,GAAyB2B,UAAU,CAACF,QAAQ,CAACzB,aAAV,EAAyB,EAAzB,CAAnC;AACAJ,IAAAA,QAAQ,CAACK,WAAT,GAAuB0B,UAAU,CAACF,QAAQ,CAACxB,WAAV,EAAuB,EAAvB,CAAjC;AACAL,IAAAA,QAAQ,CAACM,SAAT,GAAqByB,UAAU,CAACF,QAAQ,CAACvB,SAAV,EAAqB,EAArB,CAA/B;AACAN,IAAAA,QAAQ,CAACO,UAAT,GAAsBwB,UAAU,CAACF,QAAQ,CAACtB,UAAV,EAAsB,EAAtB,CAAhC;AACAyB,IAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;AACD,GATD;;AAWA,WAAStB,WAAT,CAAqBF,CAArB,EAAwB;AACtBZ,IAAAA,CAAC,CAACqC,IAAF;AACArC,IAAAA,CAAC,CAACsC,SAAF,CAAYrC,MAAZ,EAAoBA,MAApB;AACAD,IAAAA,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACwC,EAAF,GAAO,CAAhB;AACAxC,IAAAA,CAAC,CAACyC,QAAF;AACAzC,IAAAA,CAAC,CAAC0C,IAAF,CAAO,GAAP;AACA1C,IAAAA,CAAC,CAAC2C,UAAF;AACA,QAAIC,KAAJ;;AACA,QAAIhC,CAAC,GAAG,CAAR,EAAW;AACT,WAAK,IAAIiC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,CAApB,EAAuBiC,CAAC,EAAxB,EAA4B;AAC1BD,QAAAA,KAAK,GAAG5C,CAAC,CAAC8C,MAAF,GAAWD,CAAX,GAAejC,CAAvB;AACAZ,QAAAA,CAAC,CAAC+C,MAAF,CAAS9C,MAAM,GAAGD,CAAC,CAACgD,GAAF,CAAMJ,KAAN,CAAlB,EAAgC3C,MAAM,GAAGD,CAAC,CAACiD,GAAF,CAAML,KAAN,CAAzC;AACD;AACF;;AACD5C,IAAAA,CAAC,CAACkD,QAAF,CAAWlD,CAAC,CAACmD,KAAb;AACAnD,IAAAA,CAAC,CAACoD,GAAF;AACD;;AAED,WAASzB,SAAT,GAAqB;AACnB,QAAI0B,CAAC,GAAGrD,CAAC,CAACsD,MAAF,GAAWtD,CAAC,CAACuD,KAAF,GAAQ,CAA3B;AACA,QAAIC,CAAC,GAAGxD,CAAC,CAACyD,MAAF,GAAWzD,CAAC,CAAC0D,MAAF,GAAS,CAA5B;AACA,WAAO;AACLL,MAAAA,CAAC,EAAEA,CADE;AAELG,MAAAA,CAAC,EAAEA,CAFE;AAGLG,MAAAA,CAAC,EAAE3D,CAAC,CAAC4D,IAAF,CAAO5D,CAAC,CAAC6D,EAAF,CAAKR,CAAL,IAAUrD,CAAC,CAAC6D,EAAF,CAAKL,CAAL,CAAjB,CAHE;AAILM,MAAAA,EAAE,EAAE9D,CAAC,CAACwC,EAAF,GAAOxC,CAAC,CAAC+D,KAAF,CAAQP,CAAR,EAAWH,CAAX;AAJN,KAAP;AAMD;;AAED,WAASW,QAAT,CAAkBtC,MAAlB,EAA0BvB,QAA1B,EAAoC;AAClC,QAAIuB,MAAM,CAACiC,CAAP,GAAW1D,MAAf,EAAuB;AACrB,aAAOD,CAAC,CAACiE,KAAF,CAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,CAAP;AACD;;AACD,QAAIC,CAAC,GAAG,CAAC/D,QAAQ,CAAC8B,SAAT,IAAsBP,MAAM,CAACoC,EAAP,GAAY9D,CAAC,CAAC8C,MAAd,GAAuB,IAA7C,IAAqD,CAArD,GAAyD3C,QAAQ,CAACE,SAAT,GAAqB,KAA/E,IAAwF,GAAhG;AACA,QAAI8D,CAAC,GAAGnE,CAAC,CAACoE,GAAF,CAAM1C,MAAM,CAACiC,CAAP,GAAW1D,MAAjB,EAAyB,MAAME,QAAQ,CAACO,UAAxC,CAAR;AACA,QAAI2D,CAAC,GAAI,MAAM,MAAMrE,CAAC,CAACoE,GAAF,CAAM1C,MAAM,CAACiC,CAAP,GAAW1D,MAAjB,EAAyB,MAAME,QAAQ,CAACO,UAAxC,CAArB;AACA,QAAI4D,CAAC,GAAGnE,QAAQ,CAACK,WAAT,GAAuB,KAA/B;AACA,WAAOR,CAAC,CAACiE,KAAF,CAAQC,CAAR,EAAWC,CAAX,EAAcE,CAAd,EAAiBC,CAAjB,CAAP;AACD;;AAED,WAASC,YAAT,CAAsB7C,MAAtB,EAA8BvB,QAA9B,EAAwC;AACtC,WAAOH,CAAC,CAACwC,EAAF,GAAOxC,CAAC,CAACoE,GAAF,CAAM,CAACnE,MAAM,GAAGyB,MAAM,CAACiC,CAAjB,IAAsB1D,MAA5B,EAAoCE,QAAQ,CAACM,SAA7C,CAAd;AACD;;AAED,WAASgB,eAAT,GAA2B;AACzB,QAAI+C,UAAU,GAAGxE,CAAC,CAACyE,MAAF,EAAjB;AACA,QAAIjD,QAAQ,GAAGgD,UAAU,GAAGtE,UAA5B;AACAA,IAAAA,UAAU,GAAGsE,UAAb;AACA,WAAOhD,QAAQ,GAAG,MAAlB;AACD;;AAED,WAASkD,WAAT,CAAqBvE,QAArB,EAA+BqB,QAA/B,EAAyC;AACvC,QAAImD,MAAM,GAAGnD,QAAQ,GAAGrB,QAAQ,CAACG,SAAjC;AACA,QAAIsE,QAAQ,GAAG5E,CAAC,CAAC6E,KAAF,CAAQF,MAAR,CAAf;;AACA,QAAI3E,CAAC,CAAC8E,MAAF,CAAS,CAAT,EAAY,CAAZ,IAAiBH,MAAM,GAAG,CAA9B,EAAiC;AAC/BC,MAAAA,QAAQ,IAAI,CAAZ;AACD;;AACD,WAAOA,QAAP;AACD;;AAED,WAASG,QAAT,CAAkBC,IAAlB,EAAwB;AACtBhF,IAAAA,CAAC,CAACqC,IAAF;AACArC,IAAAA,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAAC8E,MAAF,CAAS,CAACE,IAAD,GAAM,CAAf,EAAkBA,IAAI,GAAC,CAAvB,CAAT;AACAhF,IAAAA,CAAC,CAACiF,IAAF,CAAO,CAAP,EAAU,CAAC,CAAD,GAAKhF,MAAf,EAAuB,CAAvB,EAA0B,IAAIA,MAA9B;AACAD,IAAAA,CAAC,CAACoD,GAAF;AACD;;AAED,WAASvB,SAAT,CAAmBH,MAAnB,EAA2BvB,QAA3B,EAAqCqB,QAArC,EAA+C;AAC7C,QAAIE,MAAM,CAACiC,CAAP,GAAW1D,MAAf,EAAuB;AACrB;AACD;;AACD,QAAI2E,QAAQ,GAAGF,WAAW,CAACvE,QAAD,EAAWqB,QAAX,CAA1B;AACA,QAAIwD,IAAI,GAAGT,YAAY,CAAC7C,MAAD,EAASvB,QAAT,CAAvB;AACAH,IAAAA,CAAC,CAACqC,IAAF;AACArC,IAAAA,CAAC,CAACsC,SAAF,CAAYZ,MAAM,CAAC2B,CAAP,GAAWrD,CAAC,CAACuD,KAAF,GAAQ,CAA/B,EAAkC7B,MAAM,CAAC8B,CAAP,GAAWxD,CAAC,CAAC0D,MAAF,GAAS,CAAtD;AACA1D,IAAAA,CAAC,CAACuC,MAAF,CAASb,MAAM,CAACoC,EAAhB;AACA9D,IAAAA,CAAC,CAACkF,YAAF,CAAe/E,QAAQ,CAACI,aAAxB;AACAP,IAAAA,CAAC,CAACmF,MAAF,CAASnB,QAAQ,CAACtC,MAAD,EAASvB,QAAT,CAAjB;;AACA,SAAK,IAAI0C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+B,QAApB,EAA8B/B,CAAC,EAA/B,EAAmC;AACjCkC,MAAAA,QAAQ,CAACC,IAAD,CAAR;AACD;;AACDhF,IAAAA,CAAC,CAACoD,GAAF;AACD;;AAED,WAASxB,UAAT,GAAsB;AACpB,WAAO,CAAC5B,CAAC,CAACoF,SAAH,IAAgBpF,CAAC,CAACqF,cAAzB;AACD;AACF,CAtID;;AAwIA,eAAetF,MAAf","sourcesContent":["const sketch = (p) => {\n  let radius = 0;\n  let lastMillis = 0;\n  let settings = {\n    numSides: 3,\n    hueOffset: 0,\n    lineSpeed: 1000,\n    lineThickness: 1,\n    lineOpacity: 50,\n    spanPower: 1,\n    colorPower: 2\n  }\n\n  function clearPolygon(n) {\n    p.background(55);\n    drawPolygon(n);\n  }\n\n  p.setup = function() {\n    let n = 5;\n    radius = p.min(window.innerWidth, window.innerHeight) / 2;\n    p.createCanvas(2 * radius, 2 * radius);\n    p.colorMode(p.HSB, 1);\n    clearPolygon(n);\n  }\n\n  p.draw = function() {\n    let ellapsed = getEllapsedTime();\n    let coords = getCoords();\n    //let settings = getSettings();\n    if (shouldDraw()) {\n      makeLines(coords, settings, ellapsed);\n    }\n    drawBorder();\n  }\n\n  p.interpretProps = function({ controls }) {\n    settings.hueCycles = parseFloat(controls.hueCycles, 10);\n    settings.hueOffset = parseFloat(controls.hueOffset, 10);\n    settings.lineSpeed = parseFloat(controls.lineSpeed, 10);\n    settings.lineThickness = parseFloat(controls.lineThickness, 10);\n    settings.lineOpacity = parseFloat(controls.lineOpacity, 10);\n    settings.spanPower = parseFloat(controls.spanPower, 10);\n    settings.colorPower = parseFloat(controls.colorPower, 10);\n    console.log(\"SETTINGS NOW: \")\n  }\n\n  function drawPolygon(n) {\n    p.push();\n    p.translate(radius, radius);\n    p.rotate(p.PI / 2);\n    p.noStroke();\n    p.fill(255);\n    p.beginShape();\n    let angle;\n    if (n % 2) {\n      for (let i = 0; i < n; i++) {\n        angle = p.TWO_PI * i / n;\n        p.vertex(radius * p.cos(angle), radius * p.sin(angle));\n      }\n    }\n    p.endShape(p.CLOSE);\n    p.pop();\n  }\n\n  function getCoords() {\n    let x = p.mouseX - p.width/2;\n    let y = p.mouseY - p.height/2;\n    return {\n      x: x,\n      y: y,\n      r: p.sqrt(p.sq(x) + p.sq(y)),\n      th: p.PI + p.atan2(y, x)\n    };\n  }\n\n  function getColor(coords, settings) {\n    if (coords.r > radius) {\n      return p.color(0, 0, 0, 1);\n    }\n    let h = (settings.hueCycles * (coords.th / p.TWO_PI + 1.75) + 1 + settings.hueOffset / 360.0) % 1.0\n    let s = p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    let b = (0.5 + 0.5 * p.pow(coords.r / radius, 1.0 / settings.colorPower));\n    let a = settings.lineOpacity / 100.0;\n    return p.color(h, s, b, a);\n  }\n\n  function getAngleSpan(coords, settings) {\n    return p.PI * p.pow((radius - coords.r) / radius, settings.spanPower);\n  }\n\n  function getEllapsedTime() {\n    let nextMillis = p.millis();\n    let ellapsed = nextMillis - lastMillis;\n    lastMillis = nextMillis;\n    return ellapsed / 1000.0;\n  }\n\n  function getNumLines(settings, ellapsed) {\n    let factor = ellapsed * settings.lineSpeed;\n    let numLines = p.floor(factor);\n    if (p.random(0, 1) < factor % 1) {\n      numLines += 1;\n    }\n    return numLines;\n  }\n\n  function drawLine(span) {\n    p.push();\n    p.rotate(p.random(-span/2, span/2));\n    p.line(0, -2 * radius, 0, 2 * radius);\n    p.pop();\n  }\n\n  function makeLines(coords, settings, ellapsed) {\n    if (coords.r > radius) {\n      return;\n    }\n    let numLines = getNumLines(settings, ellapsed);\n    let span = getAngleSpan(coords, settings);\n    p.push();\n    p.translate(coords.x + p.width/2, coords.y + p.height/2);\n    p.rotate(coords.th);\n    p.strokeWeight(settings.lineThickness);\n    p.stroke(getColor(coords, settings));\n    for (let i = 0; i < numLines; i++) {\n      drawLine(span);\n    }\n    p.pop();\n  }\n\n  function shouldDraw() {\n    return !p.isBlocked && p.mouseIsPressed;\n  }\n};\n\nexport default sketch;\n"]},"metadata":{},"sourceType":"module"}