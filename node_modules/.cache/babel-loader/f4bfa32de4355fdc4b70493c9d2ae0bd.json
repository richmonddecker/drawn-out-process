{"ast":null,"code":"var sketch = function sketch(p) {\n  var radius = 0;\n  var lastMillis = 0;\n  var settings = {\n    numSides: 3,\n    hueOffset: 0,\n    lineSpeed: 1000,\n    lineThickness: 1,\n    lineOpacity: 50,\n    spanPower: 1,\n    colorPower: 2\n  };\n\n  function clearPolygon(n) {\n    p.background(55);\n    drawPolygon(n);\n  }\n\n  p.setup = function () {\n    var n = 5;\n    radius = p.min(window.innerWidth, window.innerHeight) / 2;\n    p.createCanvas(2 * radius, 2 * radius);\n    p.colorMode(p.HSB, 1);\n    clearPolygon(n);\n  };\n\n  p.draw = function () {\n    var ellapsed = getEllapsedTime();\n    var coords = getCoords(); //let settings = getSettings();\n\n    if (shouldDraw()) {\n      makeLines(coords, settings, ellapsed);\n    }\n\n    drawPolygon(n);\n  };\n\n  p.interpretProps = function (_ref) {\n    var controls = _ref.controls;\n    settings.hueCycles = parseFloat(controls.hueCycles, 10);\n    settings.hueOffset = parseFloat(controls.hueOffset, 10);\n    settings.lineSpeed = parseFloat(controls.lineSpeed, 10);\n    settings.lineThickness = parseFloat(controls.lineThickness, 10);\n    settings.lineOpacity = parseFloat(controls.lineOpacity, 10);\n    settings.spanPower = parseFloat(controls.spanPower, 10);\n    settings.colorPower = parseFloat(controls.colorPower, 10);\n    console.log(\"SETTINGS NOW: \");\n  };\n\n  function drawPolygon(n) {\n    p.push();\n    p.translate(radius, radius);\n    p.rotate(p.PI / 2);\n    p.noStroke();\n    p.fill(255);\n    p.beginShape();\n    var angle;\n\n    if (n % 2) {\n      for (var i = 0; i < n; i++) {\n        angle = p.TWO_PI * i / n;\n        p.vertex(radius * p.cos(angle), radius * p.sin(angle));\n      }\n    }\n\n    p.endShape(p.CLOSE);\n    p.pop();\n  }\n\n  function getCoords() {\n    var x = p.mouseX - p.width / 2;\n    var y = p.mouseY - p.height / 2;\n    return {\n      x: x,\n      y: y,\n      r: p.sqrt(p.sq(x) + p.sq(y)),\n      th: p.PI + p.atan2(y, x)\n    };\n  }\n\n  function getColor(coords, settings) {\n    if (coords.r > radius) {\n      return p.color(0, 0, 0, 1);\n    }\n\n    var h = (settings.hueCycles * (coords.th / p.TWO_PI + 1.75) + 1 + settings.hueOffset / 360.0) % 1.0;\n    var s = p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    var b = 0.5 + 0.5 * p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    var a = settings.lineOpacity / 100.0;\n    return p.color(h, s, b, a);\n  }\n\n  function getAngleSpan(coords, settings) {\n    return p.PI * p.pow((radius - coords.r) / radius, settings.spanPower);\n  }\n\n  function getEllapsedTime() {\n    var nextMillis = p.millis();\n    var ellapsed = nextMillis - lastMillis;\n    lastMillis = nextMillis;\n    return ellapsed / 1000.0;\n  }\n\n  function getNumLines(settings, ellapsed) {\n    var factor = ellapsed * settings.lineSpeed;\n    var numLines = p.floor(factor);\n\n    if (p.random(0, 1) < factor % 1) {\n      numLines += 1;\n    }\n\n    return numLines;\n  }\n\n  function drawLine(span) {\n    p.push();\n    p.rotate(p.random(-span / 2, span / 2));\n    p.line(0, -2 * radius, 0, 2 * radius);\n    p.pop();\n  }\n\n  function makeLines(coords, settings, ellapsed) {\n    if (coords.r > radius) {\n      return;\n    }\n\n    var numLines = getNumLines(settings, ellapsed);\n    var span = getAngleSpan(coords, settings);\n    p.push();\n    p.translate(coords.x + p.width / 2, coords.y + p.height / 2);\n    p.rotate(coords.th);\n    p.strokeWeight(settings.lineThickness);\n    p.stroke(getColor(coords, settings));\n\n    for (var i = 0; i < numLines; i++) {\n      drawLine(span);\n    }\n\n    p.pop();\n  }\n\n  function shouldDraw() {\n    return !p.isBlocked && p.mouseIsPressed;\n  }\n};\n\nexport default sketch;","map":{"version":3,"sources":["/Users/richmonddecker/Documents/DrawnOutProcess/drawn-out-process/src/sketches/polystrings.js"],"names":["sketch","p","radius","lastMillis","settings","numSides","hueOffset","lineSpeed","lineThickness","lineOpacity","spanPower","colorPower","clearPolygon","n","background","drawPolygon","setup","min","window","innerWidth","innerHeight","createCanvas","colorMode","HSB","draw","ellapsed","getEllapsedTime","coords","getCoords","shouldDraw","makeLines","interpretProps","controls","hueCycles","parseFloat","console","log","push","translate","rotate","PI","noStroke","fill","beginShape","angle","i","TWO_PI","vertex","cos","sin","endShape","CLOSE","pop","x","mouseX","width","y","mouseY","height","r","sqrt","sq","th","atan2","getColor","color","h","s","pow","b","a","getAngleSpan","nextMillis","millis","getNumLines","factor","numLines","floor","random","drawLine","span","line","strokeWeight","stroke","isBlocked","mouseIsPressed"],"mappings":"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","sourcesContent":["const sketch = (p) => {\n  let radius = 0;\n  let lastMillis = 0;\n  let settings = {\n    numSides: 3,\n    hueOffset: 0,\n    lineSpeed: 1000,\n    lineThickness: 1,\n    lineOpacity: 50,\n    spanPower: 1,\n    colorPower: 2\n  }\n\n  function clearPolygon(n) {\n    p.background(55);\n    drawPolygon(n);\n  }\n\n  p.setup = function() {\n    let n = 5;\n    radius = p.min(window.innerWidth, window.innerHeight) / 2;\n    p.createCanvas(2 * radius, 2 * radius);\n    p.colorMode(p.HSB, 1);\n    clearPolygon(n);\n  }\n\n  p.draw = function() {\n    let ellapsed = getEllapsedTime();\n    let coords = getCoords();\n    //let settings = getSettings();\n    if (shouldDraw()) {\n      makeLines(coords, settings, ellapsed);\n    }\n    drawPolygon(n);\n  }\n\n  p.interpretProps = function({ controls }) {\n    settings.hueCycles = parseFloat(controls.hueCycles, 10);\n    settings.hueOffset = parseFloat(controls.hueOffset, 10);\n    settings.lineSpeed = parseFloat(controls.lineSpeed, 10);\n    settings.lineThickness = parseFloat(controls.lineThickness, 10);\n    settings.lineOpacity = parseFloat(controls.lineOpacity, 10);\n    settings.spanPower = parseFloat(controls.spanPower, 10);\n    settings.colorPower = parseFloat(controls.colorPower, 10);\n    console.log(\"SETTINGS NOW: \")\n  }\n\n  function drawPolygon(n) {\n    p.push();\n    p.translate(radius, radius);\n    p.rotate(p.PI / 2);\n    p.noStroke();\n    p.fill(255);\n    p.beginShape();\n    let angle;\n    if (n % 2) {\n      for (let i = 0; i < n; i++) {\n        angle = p.TWO_PI * i / n;\n        p.vertex(radius * p.cos(angle), radius * p.sin(angle));\n      }\n    }\n    p.endShape(p.CLOSE);\n    p.pop();\n  }\n\n  function getCoords() {\n    let x = p.mouseX - p.width/2;\n    let y = p.mouseY - p.height/2;\n    return {\n      x: x,\n      y: y,\n      r: p.sqrt(p.sq(x) + p.sq(y)),\n      th: p.PI + p.atan2(y, x)\n    };\n  }\n\n  function getColor(coords, settings) {\n    if (coords.r > radius) {\n      return p.color(0, 0, 0, 1);\n    }\n    let h = (settings.hueCycles * (coords.th / p.TWO_PI + 1.75) + 1 + settings.hueOffset / 360.0) % 1.0\n    let s = p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    let b = (0.5 + 0.5 * p.pow(coords.r / radius, 1.0 / settings.colorPower));\n    let a = settings.lineOpacity / 100.0;\n    return p.color(h, s, b, a);\n  }\n\n  function getAngleSpan(coords, settings) {\n    return p.PI * p.pow((radius - coords.r) / radius, settings.spanPower);\n  }\n\n  function getEllapsedTime() {\n    let nextMillis = p.millis();\n    let ellapsed = nextMillis - lastMillis;\n    lastMillis = nextMillis;\n    return ellapsed / 1000.0;\n  }\n\n  function getNumLines(settings, ellapsed) {\n    let factor = ellapsed * settings.lineSpeed;\n    let numLines = p.floor(factor);\n    if (p.random(0, 1) < factor % 1) {\n      numLines += 1;\n    }\n    return numLines;\n  }\n\n  function drawLine(span) {\n    p.push();\n    p.rotate(p.random(-span/2, span/2));\n    p.line(0, -2 * radius, 0, 2 * radius);\n    p.pop();\n  }\n\n  function makeLines(coords, settings, ellapsed) {\n    if (coords.r > radius) {\n      return;\n    }\n    let numLines = getNumLines(settings, ellapsed);\n    let span = getAngleSpan(coords, settings);\n    p.push();\n    p.translate(coords.x + p.width/2, coords.y + p.height/2);\n    p.rotate(coords.th);\n    p.strokeWeight(settings.lineThickness);\n    p.stroke(getColor(coords, settings));\n    for (let i = 0; i < numLines; i++) {\n      drawLine(span);\n    }\n    p.pop();\n  }\n\n  function shouldDraw() {\n    return !p.isBlocked && p.mouseIsPressed;\n  }\n};\n\nexport default sketch;\n"]},"metadata":{},"sourceType":"module"}