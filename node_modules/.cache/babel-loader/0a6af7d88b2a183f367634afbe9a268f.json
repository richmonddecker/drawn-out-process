{"ast":null,"code":"var sketch = function sketch(p) {\n  var radius = 0;\n  var lastMillis = 0;\n  var settings = {\n    numSides: 3\n  };\n\n  function clearPolygon(n) {\n    p.background(0.3);\n    drawPolygon(n);\n  }\n\n  p.setup = function () {\n    radius = p.min(window.innerWidth, window.innerHeight) / 2;\n    p.createCanvas(2 * radius, 2 * radius);\n    p.colorMode(p.HSB, 1);\n    clearPolygon(settings.numSides);\n  };\n\n  p.draw = function () {\n    var ellapsed = getEllapsedTime();\n    var coords = getCoords(); //let settings = getSettings();\n\n    if (shouldDraw()) {\n      makeLines(coords, settings, ellapsed);\n    }\n\n    drawPolygon(settings.numSides);\n  };\n\n  p.interpretProps = function (_ref) {\n    var controls = _ref.controls;\n    console.log(\"SETTINGS NOW: \");\n  };\n\n  function sidewaysFactor(n) {\n    // Get the horizontal factor for a polygon of n sides.\n    var cosineSum = 0;\n\n    for (var i = 0; i < p.floor((n + 1) / 4); i++) {\n      cosineSum += p.cos(p.TWO_PI / n);\n    }\n\n    return cosineSum * 2 * p.sin(p.PI / n);\n  }\n\n  function drawPolygon(n) {\n    var factor = sidewaysFactor(n);\n    var size = radius * factor;\n    console.log(\"SIZE IS: \", size, factor);\n    p.push();\n    p.translate(radius, size);\n    p.rotate(-p.PI / 2);\n    p.noStroke();\n    p.fill(1);\n    p.beginShape();\n    var angle;\n\n    if (n % 2) {\n      for (var i = 0; i < n; i++) {\n        angle = p.TWO_PI * i / n;\n        p.vertex(size * p.cos(angle), size * p.sin(angle));\n      }\n    }\n\n    p.endShape(p.CLOSE);\n    p.pop();\n  }\n\n  function getCoords() {\n    var x = p.mouseX - p.width / 2;\n    var y = p.mouseY - p.height / 2;\n    return {\n      x: x,\n      y: y,\n      r: p.sqrt(p.sq(x) + p.sq(y)),\n      th: p.PI + p.atan2(y, x)\n    };\n  }\n\n  function getColor(coords, settings) {\n    if (coords.r > radius) {\n      return p.color(0, 0, 0, 1);\n    }\n\n    var h = (settings.hueCycles * (coords.th / p.TWO_PI + 1.75) + 1 + settings.hueOffset / 360.0) % 1.0;\n    var s = p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    var b = 0.5 + 0.5 * p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    var a = settings.lineOpacity / 100.0;\n    return p.color(h, s, b, a);\n  }\n\n  function getAngleSpan(coords, settings) {\n    return p.PI * p.pow((radius - coords.r) / radius, settings.spanPower);\n  }\n\n  function getEllapsedTime() {\n    var nextMillis = p.millis();\n    var ellapsed = nextMillis - lastMillis;\n    lastMillis = nextMillis;\n    return ellapsed / 1000.0;\n  }\n\n  function getNumLines(settings, ellapsed) {\n    var factor = ellapsed * settings.lineSpeed;\n    var numLines = p.floor(factor);\n\n    if (p.random(0, 1) < factor % 1) {\n      numLines += 1;\n    }\n\n    return numLines;\n  }\n\n  function drawLine(span) {\n    p.push();\n    p.rotate(p.random(-span / 2, span / 2));\n    p.line(0, -2 * radius, 0, 2 * radius);\n    p.pop();\n  }\n\n  function makeLines(coords, settings, ellapsed) {\n    if (coords.r > radius) {\n      return;\n    }\n\n    var numLines = getNumLines(settings, ellapsed);\n    var span = getAngleSpan(coords, settings);\n    p.push();\n    p.translate(coords.x + p.width / 2, coords.y + p.height / 2);\n    p.rotate(coords.th);\n    p.strokeWeight(settings.lineThickness);\n    p.stroke(getColor(coords, settings));\n\n    for (var i = 0; i < numLines; i++) {\n      drawLine(span);\n    }\n\n    p.pop();\n  }\n\n  function shouldDraw() {\n    return !p.isBlocked && p.mouseIsPressed;\n  }\n};\n\nexport default sketch;","map":{"version":3,"sources":["/Users/richmonddecker/Documents/DrawnOutProcess/drawn-out-process/src/sketches/polystrings.js"],"names":["sketch","p","radius","lastMillis","settings","numSides","clearPolygon","n","background","drawPolygon","setup","min","window","innerWidth","innerHeight","createCanvas","colorMode","HSB","draw","ellapsed","getEllapsedTime","coords","getCoords","shouldDraw","makeLines","interpretProps","controls","console","log","sidewaysFactor","cosineSum","i","floor","cos","TWO_PI","sin","PI","factor","size","push","translate","rotate","noStroke","fill","beginShape","angle","vertex","endShape","CLOSE","pop","x","mouseX","width","y","mouseY","height","r","sqrt","sq","th","atan2","getColor","color","h","hueCycles","hueOffset","s","pow","colorPower","b","a","lineOpacity","getAngleSpan","spanPower","nextMillis","millis","getNumLines","lineSpeed","numLines","random","drawLine","span","line","strokeWeight","lineThickness","stroke","isBlocked","mouseIsPressed"],"mappings":"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","sourcesContent":["const sketch = (p) => {\n  let radius = 0;\n  let lastMillis = 0;\n  let settings = {\n    numSides: 3\n  }\n\n  function clearPolygon(n) {\n    p.background(0.3);\n    drawPolygon(n);\n  }\n\n  p.setup = function() {\n    radius = p.min(window.innerWidth, window.innerHeight) / 2;\n    p.createCanvas(2 * radius, 2 * radius);\n    p.colorMode(p.HSB, 1);\n    clearPolygon(settings.numSides);\n  }\n\n  p.draw = function() {\n    let ellapsed = getEllapsedTime();\n    let coords = getCoords();\n    //let settings = getSettings();\n    if (shouldDraw()) {\n      makeLines(coords, settings, ellapsed);\n    }\n    drawPolygon(settings.numSides);\n  }\n\n  p.interpretProps = function({ controls }) {\n    console.log(\"SETTINGS NOW: \")\n  }\n\n  function sidewaysFactor(n) {\n    // Get the horizontal factor for a polygon of n sides.\n    let cosineSum = 0;\n    for (let i = 0; i < p.floor((n + 1) / 4); i++) {\n      cosineSum += p.cos(p.TWO_PI / n);\n    }\n    return cosineSum * 2 * p.sin(p.PI / n);\n  }\n\n  function drawPolygon(n) {\n    const factor = sidewaysFactor(n);\n    const size = radius * factor;\n    console.log(\"SIZE IS: \", size, factor)\n    p.push();\n    p.translate(radius, size);\n    p.rotate(-p.PI / 2);\n    p.noStroke();\n    p.fill(1);\n    p.beginShape();\n    let angle;\n    if (n % 2) {\n      for (let i = 0; i < n; i++) {\n        angle = p.TWO_PI * i / n;\n        p.vertex(size * p.cos(angle), size * p.sin(angle));\n      }\n    }\n    p.endShape(p.CLOSE);\n    p.pop();\n  }\n\n  function getCoords() {\n    let x = p.mouseX - p.width/2;\n    let y = p.mouseY - p.height/2;\n    return {\n      x: x,\n      y: y,\n      r: p.sqrt(p.sq(x) + p.sq(y)),\n      th: p.PI + p.atan2(y, x)\n    };\n  }\n\n  function getColor(coords, settings) {\n    if (coords.r > radius) {\n      return p.color(0, 0, 0, 1);\n    }\n    let h = (settings.hueCycles * (coords.th / p.TWO_PI + 1.75) + 1 + settings.hueOffset / 360.0) % 1.0\n    let s = p.pow(coords.r / radius, 1.0 / settings.colorPower);\n    let b = (0.5 + 0.5 * p.pow(coords.r / radius, 1.0 / settings.colorPower));\n    let a = settings.lineOpacity / 100.0;\n    return p.color(h, s, b, a);\n  }\n\n  function getAngleSpan(coords, settings) {\n    return p.PI * p.pow((radius - coords.r) / radius, settings.spanPower);\n  }\n\n  function getEllapsedTime() {\n    let nextMillis = p.millis();\n    let ellapsed = nextMillis - lastMillis;\n    lastMillis = nextMillis;\n    return ellapsed / 1000.0;\n  }\n\n  function getNumLines(settings, ellapsed) {\n    let factor = ellapsed * settings.lineSpeed;\n    let numLines = p.floor(factor);\n    if (p.random(0, 1) < factor % 1) {\n      numLines += 1;\n    }\n    return numLines;\n  }\n\n  function drawLine(span) {\n    p.push();\n    p.rotate(p.random(-span/2, span/2));\n    p.line(0, -2 * radius, 0, 2 * radius);\n    p.pop();\n  }\n\n  function makeLines(coords, settings, ellapsed) {\n    if (coords.r > radius) {\n      return;\n    }\n    let numLines = getNumLines(settings, ellapsed);\n    let span = getAngleSpan(coords, settings);\n    p.push();\n    p.translate(coords.x + p.width/2, coords.y + p.height/2);\n    p.rotate(coords.th);\n    p.strokeWeight(settings.lineThickness);\n    p.stroke(getColor(coords, settings));\n    for (let i = 0; i < numLines; i++) {\n      drawLine(span);\n    }\n    p.pop();\n  }\n\n  function shouldDraw() {\n    return !p.isBlocked && p.mouseIsPressed;\n  }\n};\n\nexport default sketch;\n"]},"metadata":{},"sourceType":"module"}